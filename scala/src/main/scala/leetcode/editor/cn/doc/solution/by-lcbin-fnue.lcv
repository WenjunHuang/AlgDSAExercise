**æ–¹æ³•ä¸€ï¼šå“ˆå¸Œè¡¨ + å‰ç¼€å’Œ**

æˆ‘ä»¬å¯ä»¥å°†é—®é¢˜è½¬æ¢ä¸ºæ±‚ä¸­é—´è¿ç»­å­æ•°ç»„çš„æœ€å¤§é•¿åº¦ï¼Œä½¿å¾—å­æ•°ç»„çš„å’Œä¸º $x = sum(nums) - x$ã€‚

å®šä¹‰ä¸€ä¸ªå“ˆå¸Œè¡¨ `vis`ï¼Œå…¶ä¸­ `vis[s]` è¡¨ç¤ºå‰ç¼€å’Œä¸º $s$ çš„æœ€å°ä¸‹æ ‡ã€‚

éå†æ•°ç»„ `nums`ï¼Œå¯¹äºæ¯ä¸ªå…ƒç´  $nums[i]$ï¼Œæˆ‘ä»¬å…ˆå°† $nums[i]$ åŠ åˆ°å‰ç¼€å’Œ $s$ ä¸Šï¼Œå¦‚æœå“ˆå¸Œè¡¨ä¸­ä¸å­˜åœ¨ $s$ï¼Œåˆ™å°†å…¶åŠ å…¥å“ˆå¸Œè¡¨ï¼Œå…¶å€¼ä¸ºå½“å‰ä¸‹æ ‡ $i$ã€‚ç„¶åæˆ‘ä»¬åˆ¤æ–­ $s - x$ æ˜¯å¦åœ¨å“ˆå¸Œè¡¨ä¸­ï¼Œå¦‚æœå­˜åœ¨ï¼Œåˆ™è¯´æ˜å­˜åœ¨ä¸€ä¸ªä¸‹æ ‡ $j$ï¼Œä½¿å¾— $nums[j + 1,..i]$ çš„å’Œä¸º $x$ï¼Œæ­¤æ—¶æˆ‘ä»¬æ›´æ–°ç­”æ¡ˆçš„æœ€å°å€¼ï¼Œå³ $ans = min(ans, n - (i - j))$ã€‚

éå†ç»“æŸï¼Œå¦‚æœæ‰¾ä¸åˆ°æ»¡è¶³æ¡ä»¶çš„å­æ•°ç»„ï¼Œè¿”å› $-1$ï¼Œå¦åˆ™è¿”å› $ans$ã€‚

* [sol1-Python3]

```python
class Solution:
    def minOperations(self, nums: List[int], x: int) -> int:
        x = sum(nums) - x
        vis = {0: -1}
        ans = inf
        s, n = 0, len(nums)
        for i, v in enumerate(nums):
            s += v
            if s not in vis:
                vis[s] = i
            if s - x in vis:
                j = vis[s - x]
                ans = min(ans, n - (i - j))
        return -1 if ans == inf else ans
```

* [sol1-Java]

```java
class Solution {
    public int minOperations(int[] nums, int x) {
        x = -x;
        for (int v : nums) {
            x += v;
        }
        Map<Integer, Integer> vis = new HashMap<>();
        vis.put(0, -1);
        int n = nums.length;
        int ans = 1 << 30;
        for (int i = 0, s = 0; i < n; ++i) {
            s += nums[i];
            vis.putIfAbsent(s, i);
            if (vis.containsKey(s - x)) {
                int j = vis.get(s - x);
                ans = Math.min(ans, n - (i - j));
            }
        }
        return ans == 1 << 30 ? -1 : ans;
    }
}
```

* [sol1-C++]

```cpp
class Solution {
public:
    int minOperations(vector<int>& nums, int x) {
        x = accumulate(nums.begin(), nums.end(), 0) - x;
        unordered_map<int, int> vis{{0, -1}};
        int n = nums.size();
        int ans = 1 << 30;
        for (int i = 0, s = 0; i < n; ++i) {
            s += nums[i];
            if (!vis.count(s)) {
                vis[s] = i;
            }
            if (vis.count(s - x)) {
                int j = vis[s - x];
                ans = min(ans, n - (i - j));
            }
        }
        return ans == 1 << 30 ? -1 : ans;
    }
};
```

* [sol1-Go]

```go
func minOperations(nums []int, x int) int {
	x = -x
	for _, v := range nums {
		x += v
	}
	vis := map[int]int{0: -1}
	ans := 1 << 30
	s, n := 0, len(nums)
	for i, v := range nums {
		s += v
		if _, ok := vis[s]; !ok {
			vis[s] = i
		}
		if j, ok := vis[s-x]; ok {
			ans = min(ans, n-(i-j))
		}
	}
	if ans == 1<<30 {
		return -1
	}
	return ans
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
```

æ—¶é—´å¤æ‚åº¦ $O(n)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(n)$ã€‚å…¶ä¸­ $n$ ä¸ºæ•°ç»„ `nums` çš„é•¿åº¦ã€‚

----

**æ–¹æ³•äºŒï¼šåŒæŒ‡é’ˆ**

ä¸æ–¹æ³•ä¸€ç±»ä¼¼ï¼Œæˆ‘ä»¬è¦æ‰¾åˆ°ä¸€ä¸ªå­æ•°ç»„ï¼Œä½¿å¾—å­æ•°ç»„çš„å’Œä¸º $x = sum(nums) - x$ã€‚

å®šä¹‰ä¸¤ä¸ªæŒ‡é’ˆ $j$ å’Œ $i$ï¼Œåˆå§‹æ—¶ $i = j = 0$ï¼Œç„¶åæˆ‘ä»¬å‘å³ç§»åŠ¨æŒ‡é’ˆ $i$ï¼Œå°† $nums[i]$ åŠ åˆ°å‰ç¼€å’Œ $s$ ä¸Šã€‚å¦‚æœ $s \gt x$ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¾ªç¯å‘å³ç§»åŠ¨æŒ‡é’ˆ $j$ï¼Œå¹¶ä¸”å°† $nums[j]$ ä»å‰ç¼€å’Œ $s$ ä¸Šå‡å»ï¼Œç›´åˆ° $s \le x$ã€‚å¦‚æœ $s = x$ï¼Œæˆ‘ä»¬å¯ä»¥æ›´æ–°ç­”æ¡ˆçš„æœ€å°å€¼ï¼Œå³ $ans = min(ans, n - (i - j + 1))$ã€‚ç»§ç»­å‘å³ç§»åŠ¨æŒ‡é’ˆ $i$ï¼Œé‡å¤ä¸Šè¿°è¿‡ç¨‹ã€‚

æœ€åï¼Œå¦‚æœæ‰¾ä¸åˆ°æ»¡è¶³æ¡ä»¶çš„å­æ•°ç»„ï¼Œè¿”å› $-1$ï¼Œå¦åˆ™è¿”å› $ans$ã€‚

* [sol2-Python3]

```python
class Solution:
    def minOperations(self, nums: List[int], x: int) -> int:
        x = sum(nums) - x
        ans = inf
        n = len(nums)
        s = j = 0
        for i, v in enumerate(nums):
            s += v
            while j <= i and s > x:
                s -= nums[j]
                j += 1
            if s == x:
                ans = min(ans, n - (i - j + 1))
        return -1 if ans == inf else ans
```

* [sol2-Java]

```java
class Solution {
    public int minOperations(int[] nums, int x) {
        x = -x;
        for (int v : nums) {
            x += v;
        }
        int n = nums.length;
        int ans = 1 << 30;
        for (int i = 0, j = 0, s = 0; i < n; ++i) {
            s += nums[i];
            while (j <= i && s > x) {
                s -= nums[j++];
            }
            if (s == x) {
                ans = Math.min(ans, n - (i - j + 1));
            }
        }
        return ans == 1 << 30 ? -1 : ans;
    }
}
```

* [sol2-C++]

```cpp
class Solution {
public:
    int minOperations(vector<int>& nums, int x) {
        x = accumulate(nums.begin(), nums.end(), 0) - x;
        int n = nums.size();
        int ans = 1 << 30;
        for (int i = 0, j = 0, s = 0; i < n; ++i) {
            s += nums[i];
            while (j <= i && s > x) {
                s -= nums[j++];
            }
            if (s == x) {
                ans = min(ans, n - (i - j + 1));
            }
        }
        return ans == 1 << 30 ? -1 : ans;
    }
};
```

* [sol2-Go]

```go
func minOperations(nums []int, x int) int {
	x = -x
	for _, v := range nums {
		x += v
	}
	ans := 1 << 30
	s, n := 0, len(nums)
	j := 0
	for i, v := range nums {
		s += v
		for j <= i && s > x {
			s -= nums[j]
			j++
		}
		if s == x {
			ans = min(ans, n-(i-j+1))
		}
	}
	if ans == 1<<30 {
		return -1
	}
	return ans
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
```

æ—¶é—´å¤æ‚åº¦ $O(n)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(1)$ã€‚å…¶ä¸­ $n$ ä¸ºæ•°ç»„ `nums` çš„é•¿åº¦ã€‚

---

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿è¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿è¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆğŸ˜„~
